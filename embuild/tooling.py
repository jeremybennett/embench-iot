#!/usr/bin/env python3

# Module to handle tooling as part of the embuild package

# Copyright (C) 2019, 2020 Embecosm Limited
#
# Contributor: Jeremy Bennett <jeremy.bennett@embecosm.com>
#
# This file is part of Embench.

# SPDX-License-Identifier: GPL-3.0-or-later

"""Module to handle tooling for Embench

We provide a class which understands how to compile, and a class which
understands how to link.
"""

# System packages
import os
import subprocess

# Local packages
import embase

class Tools:
    """A class to encapsulate tools for Embench

    It provides a compiler and a linker, and has knowledge of the flags and
    how to supply source, object and executable files.
    """
    def __init__(self, cooked_args, log):
        """Constructor to set up the compiler

        The cooked_args include all the information to configure the compiler.
        """
        self.__cooked = cooked_args
        self.__log = log

    def __compile_file(self, srcf, srcdir, bindir):
        """Compile one file.

        We are supplied a source file name and source and build directories.
        The source file name is relative the source directory.  The source is
        compiled into an object file in the build directory. Both source and
        build directories are absolute.

        The source file name is stripped off its suffix (which must be .c, .S
        or .s) and an object file name generated by adding .o.  In due course
        these suffices should be configurable.

        We return a tuple of whether compilation succeeded and the name of the
        object file (relative to the build directory) or None if compilation
        failed.
        """
        root, ext = os.path.splitext(srcf)
        if not ext in {'.c', '.S', '.s.'}:
            self.__log.warning(
                f'Warning: {root}{ext} in source directory {srcdir} is '
                f'not a valid source file name: ignored.'
            )
            return False, None

        binf = root + '.o'
        abs_srcf = os.path.join(f'{srcdir}', f'{srcf}')
        abs_binf = os.path.join(f'{bindir}', f'{binf}')

        # Construct the argument list. Because we compile in the build
        # directory, the source file argument must be absolute, but the object
        # file argument must be relative.
        arglist = [self.__cooked['tools']['cc']]
        arglist.extend(self.__cooked['flags']['cflags'])
        # TODO: Should parameterize this flag
        arglist.append('-c')
        arglist.extend(
            self.__cooked['patterns']['cc_output'].format(binf).split(sep=' ')
        )
        arglist.extend(
            self.__cooked['patterns']['cc_input'].format(abs_srcf).split(sep=' ')
        )

        # Run the compilation, but only if the source file is newer than the
        # binary.
        succeeded = True
        res = None
        if not os.path.isfile(abs_binf) or (
                os.path.getmtime(abs_srcf) > os.path.getmtime(abs_binf)
        ):
            if self.__cooked['verbose']:
                self.__log.debug(f'Compiling in directory {bindir}')
                self.__log.debug(embase.arglist_to_str(arglist))

            try:
                res = subprocess.run(
                    arglist,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    cwd=bindir,
                    timeout=self.__cooked['timeout'],
                )
                if res.returncode != 0:
                    self.__log.warning(
                        f'Warning: Compilation of {srcf} from source ' +
                        f'directory {srcdir} to {binf} in build directory '
                        f'{bindir} failed'
                    )
                    succeeded = False
            except subprocess.TimeoutExpired:
                self.__log.warning(
                    f'Warning: Compilation of {srcf} from source directory ' +
                    f'{srcdir} to {binf} in build directory {bindir} timed out'
                )
                succeeded = False

        if not succeeded:
            self.__log.debug('Command was:')
            self.__log.debug(embase.arglist_to_str(arglist))
            if res:
                self.__log.debug(res.stdout.decode('utf-8'))
                self.__log.debug(res.stderr.decode('utf-8'))
            return False, None

        return True, binf

    def compile_files(self, filelist, srcdir, bindir):
        """Compile a set of files in srcdir to object files in bindir.

        The source files are named relative to the srcdir and object files are
        placed in bindir.

        The suffix of each source file (.c, .S or .s) is replaced by .o to
        create the name of the object file. In due course we should
        parameterize these suffixes.

        The result is a tuple of whether the compilation succeeded and a list
        of object files (relative to bindir).
        """
        succeeded = True
        objlist = list()
        for srcf in filelist:
            res, objf = self.__compile_file(srcf, srcdir, bindir)
            succeeded &= res
            if res:
                objlist.append(objf)

        return succeeded, objlist

    def compile_dir(self, srcdir, bindir):
        """Compile all the source files in a directory.

        A source files has suffix '.c', '.s' or '.S'. Return a tuple of
        whether we succeeded and the list of compiled object files relative to
        the build directory.
        """
        filelist = list()

        for filename in os.listdir(srcdir):
            _, ext = os.path.splitext(filename)
            full_fn = os.path.join(srcdir, filename)
            if os.path.isfile(full_fn) and (ext in {'.c', '.s', '.S'}):
                filelist.append(filename)

        # Compile the resulting files (if any)
        return self.compile_files(filelist, srcdir, bindir)

    def compile_benchmark(self, bench):
        """Compile code provided in a benchmark directory.

        Return a tuple whether we succeeded and a list of compiled objects
        suitable for linking.
        """
        srcdir = os.path.join(self.__cooked['srcdirs']['src'], bench)
        bindir = os.path.join(self.__cooked['bindirs']['src'], bench)

        # Compile all the source files (if any)
        res, objs = self.compile_dir(srcdir, bindir)

        return res, self.create_link_rel_input_list(objs)

    @staticmethod
    def __create_link_binlist(objs, support):
        """Create a list of all the binaries to be linked to create the benchmark
        executable.

        The link will be done in the benchmark build directory, so files in
        this directory are relative (the objs argument), all others (the
        support files) are absolute.
        """
        # Benchmark binaries
        binlist = objs

        # Config, support and dummy libraries
        binlist.extend(support.config_objs())
        binlist.extend(support.support_objs())
        binlist.extend(support.dummy_objs())

        return binlist

    def __create_link_arglist(self, bench, binlist):
        """Create the argument list for linking benchmark, "bench", from the
        binaries in "binlist".
        """
        arglist = [self.__cooked['tools']['ld']]
        arglist.extend(self.__cooked['flags']['ldflags'])
        arglist.extend(
            self.__cooked['patterns']['ld_output'].format(bench).split(sep=' ')
        )
        arglist.extend(binlist)
        arglist.extend(self.__cooked['libs']['user'])

        return arglist

    def link_benchmark(self, bench, objs, support):
        """Link the benchmark

        We are supplied with the name of the benchmark, a list of relative
        object files for the benchmark and a list of absolute object files for
        support.

        Return True if link is successful, False otherwise.
        """
        bindir = os.path.join(self.__cooked['bindirs']['src'], bench)

        if not os.path.isdir(bindir):
            self.__log.warning(
                'Warning: Unable to find build directory for '
                + f'benchmark {bench}'
            )
            return False

        # Create the argument list
        binlist = self.__create_link_binlist(objs, support)
        if not binlist:
            return False

        arglist = self.__create_link_arglist(bench, binlist)

        # Use a flag to track warnings, but keep going through warnings.
        succeeded = True

        # Run the link
        if self.__cooked['verbose']:
            self.__log.debug(f'Linking in directory {bindir}')
            self.__log.debug(embase.arglist_to_str(arglist))

        try:
            res = subprocess.run(
                arglist,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=bindir,
                timeout=self.__cooked['timeout']
            )
            if res.returncode != 0:
                self.__log.warning(f'Warning: Link of benchmark "{bench}" failed')
                succeeded = False
        except subprocess.TimeoutExpired:
            self.__log.warning(f'Warning: link of benchmark "{bench}" timed out')
            succeeded = False

        if not succeeded:
            self.__log.debug('In directory "' + bindir + '"')
            self.__log.debug('Command was:')
            self.__log.debug(embase.arglist_to_str(arglist))
            self.__log.debug(res.stdout.decode('utf-8'))
            self.__log.debug(res.stderr.decode('utf-8'))

        return succeeded

    def create_link_abs_input_list(self, objs, bindir):
        """Convert a list of relative object files, to a list of absolute
        object files modified by the pattern to be linker input files.
        """
        linklist = list()
        path = self.__cooked['patterns']['ld_input']
        for obj in objs:
            linklist.extend(
                path.format(os.path.join(bindir, obj)).split(sep=' ')
            )

        return linklist

    def create_link_rel_input_list(self, objs):
        """Convert a list of relative object files, to a list of relative
        object files modified by the pattern to be linker input files.
        """
        linklist = list()
        path = self.__cooked['patterns']['ld_input']
        for obj in objs:
            linklist.extend(path.format(obj).split(sep=' '))

        return linklist
